  URI 决定读取哪个 content  mProjection 数组决定读取列     mSelection:筛选条件  SORT：决定返回后list 的排序
  Cursor cursor = mResolver.query(URI, mProjection, mSelection, null, SORT);
   
   
   Uri URI = CallLog.Calls.CONTENT_URI;
  
  
          List<String> projection = new ArrayList<>();
        projection.add(CallLog.Calls._ID);
        projection.add(CallLog.Calls.TYPE);
        projection.add(CallLog.Calls.NUMBER);
        projection.add(CallLog.Calls.DATE);
        projection.add(CallLog.Calls.DURATION);
        // Note: 小米MIUI使用[simid]字段区分双卡;华为EMUI取出来的PHONE_ACCOUNT_ID值为0或1,代表主卡或副卡
        projection.add(RomUtil.isMiui() ? "simid" : CallLog.Calls.PHONE_ACCOUNT_ID);
        mProjection = projection.toArray(new String[projection.size()]);
		
  
  
   sb.append(CallLog.Calls.TYPE).append("=").append(CallLog.Calls.INCOMING_TYPE).append(" OR ");
        sb.append(CallLog.Calls.TYPE).append("=").append(CallLog.Calls.OUTGOING_TYPE).append(" OR ");
        sb.append(CallLog.Calls.TYPE).append("=").append(CallLog.Calls.MISSED_TYPE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            sb.append(" OR ").append(CallLog.Calls.TYPE).append("=")
                    .append(CallLog.Calls.REJECTED_TYPE);
        }
        mSelection = sb.toString();
		
		
	// 只读取最近200条通话记录
    private static final String SORT = CallLog.Calls.DEFAULT_SORT_ORDER + " LIMIT 200";
		
		
		
写入 
       很多机器人
        。。。。。
        。。。。。
       builder = ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                    .withValue(ContactsContract.Data.MIMETYPE,
                            ContactsContract.CommonDataKinds.Note.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.Note.NOTE, note);
            ops.add(builder.build());
          mResolver.applyBatch(ContactsContract.AUTHORITY, ops);

删除	
      
         	机器人     图纸
            builder = ContentProviderOperation.newDelete(ContactsContract.RawContacts.CONTENT_URI)
                    .withSelection(ContactsContract.RawContacts.CONTACT_ID + " = ?",
                            new String[]{String.valueOf(contact.id)});
            ops.add(builder.build());
					
				  开动的机器人	       
        ops.add(builder.build());		
		                        服务员开门
		  mResolver.applyBatch(ContactsContract.AUTHORITY, ops);//删除list中的所有联系人
  
自定义的contentprovider

ContentResolver
   URI：content://net.manoel.provider.Books/books// content：// + authorities + 表


  android:authorities="net.manoel.provider.Books" //授权决定URI中间部分
 android:name=".BooksProvider"
 
package com.example.personaltools;


学习
provider 属性
net.manoel.provider.Books123 provider 授权路径

DatabaseHelper 属性
BooksProvider 的 onCreat 中初始化 DatabaseHelper

DatabaseHelper extends SQLiteOpenHelper（db操作类）
     1.通过他的构造函数传入数据库name
 DB
     2.通过 DatabaseHelper 的onCreate 函数 创建表
               db.execSQL(DATABASE_CREATE);

添加等相关属性

 1.找到对应的provider
     获取到 contentresolver
	    ContentResolver contentResolver = this.getBaseContext().getContentResolver();
      找到对应URI
	   Uri insertUri = Uri.parse("content://net.manoel.provider.Books/books"); 
	   // 特别注意其实决定调用哪个provider 只由中间部分决定 后面是不是用由接收端决定
	   
       组装数据
	      ContentValues values = new ContentValues();
            values.put("title", "lm");
            values.put("isbn", "1350000009");
	     进行操作
  		    Uri uri = contentResolver.insert(insertUri, values);
			
	
			
			
			
			