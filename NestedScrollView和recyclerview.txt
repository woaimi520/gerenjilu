RecyclerView
app builder 下：
    //recycleView
    implementation 'com.android.support:recyclerview-v7:28+'
	
注意：
	getAdapterPosition 可以在adapter中获取当前view的位置
	且一定要添加布局信息 不然 至少我在viewpage中遇到不能显示问题
	外部可以用 list和 adapter的局部变量 但是就不能实时判断变化了
	覆写的懒加载 onFragmentVisibleChange 函数应该是去加载网络变化更新的时候用 第一次 recycle 中数据会加载 即使里面什么都没做
    LinearLayoutManager 只管理一个recycleview

补充：viewpage 和 fragment+ry 配合使用的时候 可能需要懒加载
     因为一进入 就会把 可见的fragment及它旁边的两个（可配置 但是最小范围就是这样） 生命周期走到 onResume 即使不可见的 
     对于可能需要访问网络的就可能卡
     因此要懒加载 
     懒加载 注意 setUserVisibleHint（boolean）会在不可见的时候 调用一次，当可用的时候又调用一次 都在onCreatview前面
	 因此要在  setUserVisibleHint 及 onCreateView 都做处理
	 onCreateView 处理理由：setUserVisibleHint 不管是传入 true 还是false 此时可能isViewInflateFinished是false 因此不加载
	 我这里用三个变量来控制调用加载逻辑
	public boolean isloadData; //是否已经加载过数据 true：已经加载过   false:未加载过
    public boolean isViewInflateFinished;//rootview是否已经inflate 完毕
    public boolean isViewVisable;//当前的可见状态  
	
	
	
	刷新问题
	删除一个元素  
	              //相减少的奇葩 不能分开 只有连起来用 start
				     //删除范围要求：【0，list.size()-1】
                  adapter.notifyItemRemoved(j);
				  //指的是把 从 0-> 开始第几个删除 
                  adapter.notifyItemRangeChanged(j, list.size() - j);//j=1 ,1234  134   会通知 【1，2】 j即 34的位置 若 adapter.notifyItemRangeChanged(j, list.size() - j) 可能还会越界 但是加没问题
                 
                  //相减少的奇葩 不能分开 只有连起来用 end
				  
				  
	插入一个元素			  
                   //这两个组合有动画 且 位置不会出错 这个就是添加的最终形态 插入 start
                  //插入范围要求：【0，list.size()】 是包含边界的哈 例子【0，4】
                  adapter.notifyItemInserted(i);
                  //可以刷新从positionStart开始itemCount数量的item了   
                  adapter.notifyItemRangeChanged(i, list.size() - i);
                  //i=3 数据 1234  123X4 记忆把第几个(从0->)数据往后挤开 ，【3，5-3=2】 会通知到 x4的位置  （通知是指的修改后的元素位置的 onbindview调用）
				  //i=0 数据 1234 X1234 【0，5-0=5】 通知 01234的位置
                  //i=4 数据 1234 1234x 【4，5-4=1】 通知 X的位置
                  //这两个组合有动画 且 位置不会出错 这个就是添加的最终形态 end
				  
	刷新一个元素			  
	              //刷新的时候 start
				   刷新范围要求：【0，list.size()-1】 因为要先取出来改
                  //adapter.notifyItemChanged(1);//指定更新哪一个 这个更扯 我找不到规律了  list 有变化不要用  这个是用于单个刷新的 list不变化
                  //刷新的时候 end	

	添加一个元素			  
	              //添加的时候 可以直接用这个 start
                  //adapter.notifyItemInserted(list.size()); //加了不加 效果一样
                  //adapter.notifyItemRangeChanged(list.size(), list.size()); //始终是以改变后的list为准来通知 还要用到位置的
                  //或者单独用 adapter.notifyItemChanged(list.size());
                  //添加的时候 可以直接用这个 start


1.它需要一个adapter来处理数据 每个item 都有一个 holder
  adpter中函数执行顺序
     * MyAdapter()
	 * 
     * getItemCount
     *
     * getItemViewType
     *
     * onCreateViewHolder
     *
	 * ViewHolder(@NonNull View itemView) {
	 *  
     * onBindViewHolde

2.里面内容的排列方向 
  由    mRecytclerView01.setLayoutManager(lin01); 决定 默认是竖着 
  XML 中设置了没得效果

3.设置间隔符
   系统自带
           mRecytclerView01.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL));   
   自定义 宽度
      rcLeft.addItemDecoration(getRecyclerViewDivider(R.drawable.inset_recyclerview_divider));//设置分割线
	  
       public RecyclerView.ItemDecoration getRecyclerViewDivider(@DrawableRes int drawableId) {
        DividerItemDecoration itemDecoration = new DividerItemDecoration(this, DividerItemDecoration.VERTICAL);
        itemDecoration.setDrawable(getResources().getDrawable(drawableId));
        return itemDecoration;
    }
   
   <?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:insetLeft="0dp">
    <!--android:insetLeft="10dp" 分割线距离左侧10dp-->
    <shape>
        <!--分割线的高度，横向的RecyclerView,这里设置宽度即可-->
        <size android:height="1dp" />
        <!--分割线的颜色-->
        <solid android:color="@color/septumColor" />
    </shape>

</inset>
   
4 添加监听问题
  ***********************************************************
  补充接口的 接口中方法都是public 变量都是public static final的
  实现类必须实现接口中的方法 包括 接口继承的方法
  
  内部类 访问外部类可以直接访问 包括私有方法 和变量 
  外部类 访问内部类需要先实例化出来 然后范文 包括私有方法和变量
  
  外部访问内部类 需要内部类 是 public 等 不能是private
  实例化方式：
  W w = new W()
  W.N n = w.new N()
  ***********************************************************
  onBindViewHolde 中 因为入参有 holder 及 position 
  否则可以用int position = getAdapterPosition()来获取位置
  所以这里添加监听最合适
  1.系统回调接口 通过
  onBindViewHolde
   viewHolder.itemView.setOnLongClickListener（new onLongClickListener）
   。。。
   ）
   viewHolder.itemView.setOnClickListener（new onClickListener）
   。。。。
   ）
   
3.外部实现接口
   OnClickListener
4. 监听回调  
   回调外部监听器的对应函数  
   
   
添加监听优化
 
   避免创建过多对象
onCreateViewHolder 和 onBindViewHolder 对时间都比较敏感，
尽量避免繁琐的操作和循环创建对象。例如创建 OnClickListener，
可以全局创建一个，然后数据通过 itemView.setTag 携带
1.设置监听
onBindViewHolde
    viewHolder.itemView.setTag(position);
        viewHolder.itemView.setOnLongClickListener(this);
        viewHolder.itemView.setOnClickListener(this);

2. MyAdapter 实现接口
 	MyAdapter extends RecyclerView.Adapter<MyAdapter.ViewHolder> implements View.OnLongClickListener, View.OnClickListener	
	
3.外部实现接口
   OnClickListener
4. 监听回调  
   回调外部监听器的对应函数   
   
如果要这么用的话哈   
特别的 在点击事件中这么判断 考虑到 删除item 重新绘制的时候 多次点击 
若此刻没有绘制好 
 int position = getAdapterPosition();
 if (position == RecyclerView.NO_POSITION) return;   
 。。。
   
   
5 判断是否到底 （ontouch 返回false/true 和 onclick 不会干扰它  这种方式感觉也不好用）
  1 添加滑动监听
 mRecytclerView01.addOnScrollListener(new RecyclerView.OnScrollListener() {  
  2 重写 
  onScrollStateChanged 外层嵌套滑动的时候滑动就会调用 显示的下的时候 滑动也会回调（即使没动）
  onScrolled 外层嵌套滑动的时候不调用 显示的下的时候 滑动不会回调（即使没动）
     
        
  3 在 onScrollStateChanged 中用 canScrollVertically（-1） /canScrollHorizontally 判断 
     参数 -1 判顶  到顶返回false
	       1 判底  到底返回false
	例如：	   
		              if(!recyclerView.canScrollVertically(1)){
                                                             Toast.makeText(MainActivity.this, "已经到达底部", Toast.LENGTH_SHORT).show();

                                                         }
                                                         if(!recyclerView.canScrollVertically(-1)){
                                                             Toast.makeText(MainActivity.this, "已经到达顶部", Toast.LENGTH_SHORT).show();

                                                         }
														 
		问题：当能滑动的时候还好用
              不能滑动的时候不管往哪个方向滑动两个判断语句都会返回true

 针对此问题
     
		            int ii= recyclerView.computeVerticalScrollExtent();//显示的
                    int iii=recyclerView.computeVerticalScrollOffset();//偏移位置 测试最小为0
                   int iiii= recyclerView.computeVerticalScrollRange();//整个高度 包括没有显示的
		   通过 ii==iiii  来判断是否显示完全  显示完全的时候只显示一种
		   
6.item 内部里面的view 点击事件
  1
onBindViewHolder
  		viewHolder.button.setTag(position);
        viewHolder.button.setOnClickListener(this);
  2
public void onClick(View v) {
        int position = (Integer) v.getTag();
        switch (v.getId()) {
            case R.id.button:
			
 3也可以使用bindview
   在 ViewHolder类中
   @OnClick 和  @OnLongClick 注意 这种方式不用要添加监听 它自己会帮你添加
   这种方式需要在最外部view 中使用 id
   
   
 外层添加  NestedScrollView
 
 NestedScrollView 没有动的时候
   recycleview 还是和之前一样的行为 
   实际动了 且没完全显示 滑动 才会回调 onScrolled

 
  NestedScrollView 动的时候
  recycleview
    没完全显示 没有滑动 也不会回调 onScrolled （比如长度很大 使用wrapcontent）
	
	NestedScrollView 不能滑动的时候 如能完全显示下内容 
	  mNestedScrollView.setOnScrollChangeListener(new NestedScrollView.OnScrollChangeListener() {
	  就不会回调
// nestedScrollView.getMeasuredHeight() 显示的高度
//nestedScrollView.getChildAt(0).getMeasuredHeight()   整个高度 包含未显示的 因为只有一个线性布局 所以是0
// scrollY 下滑距离
	
	
  