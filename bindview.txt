buider.gradle(app中的dependencies加入)：

       

implementation 'com.jakewharton:butterknife:8.8.1'
annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'

即可，使用：

@BindView(R.id.text1)
TextView textView;
代替：

findviewbyid方法。
activity 中使用
使用之前要  ButterKnife.bind(this); 
需要在       setContentView(R.layout.activity_main); 后


fragment中使用
Unbinder unbinder

在 onCreateView中
View view = inflater.inflate(initlayout(), container, true);
mUnbinder = ButterKnife.bind(this, view);
在fragment的 destory中
@Override
    public void onDestroy() {
        super.onDestroy();
     
        mUnbinder.unbind();
    }
		

adapter中使用
    public ViewHolder(@NonNull View itemView) {
            super(itemView);
            ButterKnife.bind(this,itemView);
        }
		
		
  @OnClick({R.id.button,R.id.textView}) 添加点击 这种方式不需要view 添加监听器 它会自动添加

   public void  onClick111  这个名字可以自定义
   
   
   或者
      @Override
    public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) {
        ButterKnife.bind(this, viewHolder.itemView);
    }
   
   
   
       特别注意 

包含有kotlin的话
只用修改为
 annotationProcessor 'com.jakewharton:butterknife-compile:8.8.1'
  kapt 'com.jakewharton:butterknife-compiler:8.8.1'


注意：
1没有在  @OnClick({R.id.manual_recovery,R.id. manually_delete}) 中注册的view 当点击的时候是不会走它下面的回调函数的
2 imagview 可以不用在xml中设置  android:clickable="true" 也能有点击事件
3. 
  一：在viewholder 中    ButterKnife.bind(this, itemView); 
	且 在它里面@BindView(R.id.manually_delete)
        ImageView manually_delete;
	以及
     @OnClick({R.id.manual_recovery,R.id. manually_delete})  
  结论 能收到点击事件
   二： 上述条件不变
      在adapter中添加
	      public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        ButterKnife.bind(this, holder.itemView);
    结论 依然可以在viewholder中收到点击事件
	
	 
  二： 上述条件不变
    adapter中也添加点击事件
	   @OnClick({R.id.manual_recovery,R.id. manually_delete})
    public void onClick(View v) {
	结论 viewholder中的点击事件就收不到消息了（ 没看源码 应该是自己优化的）
